rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // User documents - users can read/write their own data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Allow admins to read all users in their school for user management
      allow read: if request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin' &&
        resource.data.schoolId == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.schoolId;
    }

    // School data - multi-tenant isolation
    match /schools/{schoolId} {
      // Helper function to check if user belongs to this school
      function belongsToSchool() {
        return request.auth != null &&
               get(/databases/$(database)/documents/users/$(request.auth.uid)).data.schoolId == schoolId;
      }

      // Helper function to check user role
      function hasRole(role) {
        return request.auth != null &&
               get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
      }

      // Helper function to check if user has admin or front office role
      function canManageData() {
        return hasRole('admin') || hasRole('front_office');
      }

      // Helper function to check if user can perform dismissals
      function canDismiss() {
        return hasRole('admin') || hasRole('teacher') || hasRole('staff');
      }

      // Helper function to validate dismissal status transitions
      function isValidStatusTransition() {
        let oldStatus = resource.data.status;
        let newStatus = request.resource.data.status;

        // Allow valid transitions: waiting → at_cone → dismissed
        return (oldStatus == 'waiting' && newStatus == 'at_cone') ||
               (oldStatus == 'at_cone' && newStatus == 'dismissed') ||
               (oldStatus != 'historical' && newStatus == 'historical'); // Allow marking as historical
      }

      // Helper function to check if school has active subscription
      function hasActiveSubscription() {
        let school = get(/databases/$(database)/documents/schools/$(schoolId));
        let status = school.data.subscriptionStatus;
        let trialEnd = school.data.trialEndsAt;

        return status == 'active' ||
               (status == 'trial' && trialEnd > request.time);
      }

      // Helper function to validate required fields in dismissal
      function isValidDismissal() {
        let data = request.resource.data;
        return data.keys().hasAll(['carNumber', 'studentIds', 'coneNumber', 'dismissedBy', 'dismissedAt', 'status']) &&
               data.carNumber is string &&
               data.studentIds is list &&
               data.coneNumber is number &&
               data.dismissedBy is string &&
               data.status in ['waiting', 'at_cone', 'dismissed', 'historical'];
      }

      // Students collection
      match /students/{studentId} {
        allow read: if belongsToSchool() && hasActiveSubscription();
        allow create, update, delete: if belongsToSchool() && canManageData() && hasActiveSubscription();
      }

      // Cars collection
      match /cars/{carId} {
        allow read: if belongsToSchool() && hasActiveSubscription();
        allow create, update, delete: if belongsToSchool() && canManageData() && hasActiveSubscription();
      }

      // Overrides collection
      match /overrides/{overrideId} {
        allow read: if belongsToSchool() && hasActiveSubscription();
        allow create, update, delete: if belongsToSchool() && canManageData() && hasActiveSubscription();
      }

      // Lanes collection
      match /lanes/{laneId} {
        allow read: if belongsToSchool();
        allow create, update, delete: if belongsToSchool() && hasRole('admin');
      }

      // Dismissals collection
      match /dismissals/{dismissalId} {
        allow read: if belongsToSchool() && hasActiveSubscription();
        allow create: if belongsToSchool() && canDismiss() && hasActiveSubscription() && isValidDismissal();
        allow delete: if belongsToSchool() && hasRole('admin') && hasActiveSubscription();

        // Allow status updates for 3-stage workflow (waiting → at_cone → dismissed)
        allow update: if belongsToSchool() && hasActiveSubscription() && (
          hasRole('admin') ||
          (canDismiss() && isValidStatusTransition())
        );
      }

      // School configuration (admin only)
      allow read: if belongsToSchool();
      allow write: if belongsToSchool() && hasRole('admin');
    }

    // Invitations collection (global, not under schools)
    match /invitations/{invitationId} {
      // Allow reading invitations for acceptance (anyone can read by invitation token)
      // This is needed because users accepting invitations don't have profiles yet
      allow read: if true;

      // Only authenticated users with admin role in the same school can create invitations
      allow create: if request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin' &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.schoolId == request.resource.data.schoolId;

      // Allow updating invitation status when accepting (by authenticated user with matching email)
      allow update: if request.auth != null &&
        resource.data.email == request.auth.token.email &&
        request.resource.data.status == 'accepted';

      // Allow admins to update invitations (resend, cancel) for their school
      allow update: if request.auth != null &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin' &&
        resource.data.schoolId == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.schoolId;
    }

    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}